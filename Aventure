<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>The Forest - Immersive Survival</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Press Start 2P', cursive; }
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        #gui { 
            position: absolute; top: 15px; left: 15px; color: #fff; 
            background: rgba(0,0,0,0.7); padding: 12px; border-radius: 6px; 
            pointer-events: none; z-index: 10; border: 1px solid rgba(255,255,255,0.1);
        }
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; 
            background: rgba(255,255,255,0.6); border-radius: 50%; 
            transform: translate(-50%, -50%); z-index: 5; 
        }
        .stat { font-size: 14px; margin-bottom: 5px; color: #E74C3C; font-weight: bold; }
        #instructions { 
            position: absolute; bottom: 15px; left: 15px; color: rgba(255,255,255,0.3); 
            font-size: 10px; pointer-events: none; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            line-height: 1.5;
        }
    </style>
</head>
<body>

<div id="gui">
    <div class="stat">‚ù§ HP: <span id="hp">100</span></div>
    <div class="stat">ü™µ WOOD: <span id="wood">0</span></div>
    <div class="stat">üî™ AXE: <span id="axe">NO</span></div>
</div>

<div id="crosshair"></div>
<div id="instructions">WASD: Move | Mouse: Look | Space: Attack/Action | ESC: Release Mouse</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

    // --- CONFIGURACI√ìN DE LA ESCENA ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x010302); // Fondo muy oscuro
    scene.fog = new THREE.FogExp2(0x010302, 0.08); // Niebla densa y cercana

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.y = 1.7; // Altura de los ojos del jugador

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; // Activar sombras
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombras suaves
    document.body.appendChild(renderer.domElement);

    // --- CONTROLES DE PUNTERO ---
    const controls = new PointerLockControls(camera, document.body);
    document.addEventListener('mousedown', () => controls.lock()); // Bloquear rat√≥n al hacer clic

    // --- CARGADOR DE TEXTURAS Y MODELOS ---
    const textureLoader = new THREE.TextureLoader();
    const materialLoader = new THREE.MeshStandardMaterial();

    // --- TERRENO CON TEXTURA DE ALTA CALIDAD Y RELIEVE (NORMAL MAP) ---
    const groundTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/terrain/grasslight-big.jpg');
    groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
    groundTexture.repeat.set(30, 30);
    const groundNormalMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/waternormals.jpg'); // Usamos este como ejemplo de normal map
    groundNormalMap.wrapS = groundNormalMap.wrapT = THREE.RepeatWrapping;
    groundNormalMap.repeat.set(30, 30);

    const groundMaterial = new THREE.MeshStandardMaterial({
        map: groundTexture,
        normalMap: groundNormalMap,
        roughness: 0.9,
        metalness: 0.1
    });
    const groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), groundMaterial);
    groundMesh.rotation.x = -Math.PI / 2;
    groundMesh.receiveShadow = true;
    scene.add(groundMesh);

    // --- L√çMITES DEL MUNDO (Bordes invisibles) ---
    const WORLD_EDGE = 90; // √Årea de juego m√°s grande
    const boundaryMeshes = [];

    const createBoundary = (x, y, z, rotY) => {
        const wall = new THREE.Mesh(new THREE.BoxGeometry(200, 10, 1), new THREE.MeshBasicMaterial({ visible: false }));
        wall.position.set(x, y, z);
        wall.rotation.y = rotY;
        scene.add(wall);
        boundaryMeshes.push(wall);
    };
    createBoundary(0, 5, WORLD_EDGE, 0);       // Norte
    createBoundary(0, 5, -WORLD_EDGE, 0);      // Sur
    createBoundary(WORLD_EDGE, 5, 0, Math.PI / 2);  // Este
    createBoundary(-WORLD_EDGE, 5, 0, Math.PI / 2); // Oeste

    // --- ILUMINACI√ìN GLOBAL (Luz de la luna/lejana) ---
    const directionalLight = new THREE.DirectionalLight(0xadd8e6, 0.2); // Azulado tenue
    directionalLight.position.set(10, 20, 10);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024; // Resoluci√≥n de sombras
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -20;
    directionalLight.shadow.camera.right = 20;
    directionalLight.shadow.camera.top = 20;
    directionalLight.shadow.camera.bottom = -20;
    scene.add(directionalLight);
    scene.add(new THREE.AmbientLight(0x222222, 0.4)); // Luz ambiental muy baja

    // --- LINTERNA DEL JUGADOR ---
    const flashlight = new THREE.SpotLight(0xffffee, 50, 20, Math.PI / 6, 0.5, 2); // Color m√°s c√°lido
    flashlight.castShadow = true;
    flashlight.shadow.mapSize.width = 512;
    flashlight.shadow.mapSize.height = 512;
    flashlight.shadow.camera.far = 20;
    scene.add(flashlight);

    // --- OBJETOS DEL MUNDO (√ÅRBOLES Y RECURSOS) ---
    const worldObjects = [];

    // Funci√≥n para generar un √°rbol (m√°s detallado)
    function createDetailedTree(x, z) {
        const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 4, 8);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4d2902, roughness: 0.8 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 2;
        trunk.castShadow = true;

        const leavesGeo = new THREE.SphereGeometry(2.5, 8, 8); // Esfera para hojas
        const leavesMat = new THREE.MeshStandardMaterial({ color: 0x1a3d0a, roughness: 0.7 });
        const leaves = new THREE.Mesh(leavesGeo, leavesMat);
        leaves.position.y = 4.5;
        leaves.castShadow = true;

        const treeGroup = new THREE.Group();
        treeGroup.add(trunk);
        treeGroup.add(leaves);
        treeGroup.position.set(x, 0, z);
        scene.add(treeGroup);
        worldObjects.push({ mesh: treeGroup, x, z, radius: 1.5, type: 'tree' });
    }

    // Funci√≥n para crear un "monstruo can√≠bal" (ejemplo simplificado)
    const monsterMaterial = new THREE.MeshStandardMaterial({ color: 0x880000, roughness: 0.5 }); // Rojo oscuro
    function createMonster(x, z) {
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.8, 0.8), monsterMaterial);
        body.position.y = 0.9;
        body.castShadow = true;

        const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), monsterMaterial);
        head.position.y = 2.1;
        body.add(head); // Cabeza como hijo del cuerpo

        const monsterGroup = new THREE.Group();
        monsterGroup.add(body);
        monsterGroup.position.set(x, 0, z);
        scene.add(monsterGroup);
        worldObjects.push({ mesh: monsterGroup, x, z, hp: 100, radius: 1.0, type: 'monster' });
    }

    // Poblar el mundo
    for (let i = 0; i < 150; i++) { // M√°s √°rboles para mayor densidad
        const x = Math.random() * (WORLD_EDGE * 1.8) - WORLD_EDGE * 0.9;
        const z = Math.random() * (WORLD_EDGE * 1.8) - WORLD_EDGE * 0.9;
        createDetailedTree(x, z);
    }
    for (let i = 0; i < 15; i++) { // M√°s monstruos
        const x = Math.random() * (WORLD_EDGE * 1.5) - WORLD_EDGE * 0.75;
        const z = Math.random() * (WORLD_EDGE * 1.5) - WORLD_EDGE * 0.75;
        createMonster(x, z);
    }

    // --- L√ìGICA DEL JUGADOR ---
    const player = { hp: 100, wood: 0, hasAxe: false };
    const playerSpeed = 0.15; // Velocidad de movimiento
    const playerRadius = 0.5; // Radio de colisi√≥n del jugador

    const keys = { w: false, a: false, s: false, d: false, space: false };
    document.addEventListener('keydown', (e) => {
        if (controls.isLocked) {
            keys[e.key.toLowerCase()] = true;
            if (e.code === 'Space') keys.space = true;
        }
    });
    document.addEventListener('keyup', (e) => {
        if (controls.isLocked) {
            keys[e.key.toLowerCase()] = false;
            if (e.code === 'Space') keys.space = false;
        }
    });

    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    // --- GAME LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        if (controls.isLocked) {
            const delta = 0.016; // Tiempo entre frames

            // Actualizar velocidad basada en input
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            
            direction.z = Number(keys.w) - Number(keys.s);
            direction.x = Number(keys.d) - Number(keys.a);
            direction.normalize(); // Evitar movimiento diagonal m√°s r√°pido

            if (keys.w || keys.s) velocity.z -= direction.z * playerSpeed * 60 * delta;
            if (keys.a || keys.d) velocity.x -= direction.x * playerSpeed * 60 * delta;

            const prevX = camera.position.x;
            const prevZ = camera.position.z;

            // Mover la c√°mara
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            // --- COLISIONES ---
            // Colisi√≥n con l√≠mites del mundo
            if (Math.abs(camera.position.x) > WORLD_EDGE - playerRadius || Math.abs(camera.position.z) > WORLD_EDGE - playerRadius) {
                camera.position.x = prevX;
                camera.position.z = prevZ;
            }

            // Colisi√≥n con objetos (√°rboles, monstruos)
            worldObjects.forEach(obj => {
                const dist = camera.position.distanceTo(obj.mesh.position);
                if (dist < playerRadius + obj.radius) {
                    if (obj.type === 'tree') {
                        camera.position.x = prevX;
                        camera.position.z = prevZ;
                    } else if (obj.type === 'monster') {
                        // L√≥gica de combate/interacci√≥n con monstruos
                        if (keys.space) {
                             obj.hp -= 25; // Da√±o del jugador
                             player.hp -= 10; // Da√±o del monstruo
                             if (obj.hp <= 0) {
                                 scene.remove(obj.mesh);
                                 obj.radius = 0; // Quitar colisi√≥n
                                 console.log("Monstruo derrotado!");
                             }
                             if (player.hp <= 0) {
                                 alert("Has muerto... Fin del juego.");
                                 controls.unlock();
                             }
                             updateGUI();
                        } else {
                            // Si solo chocas, el monstruo te empuja un poco o te da√±a
                            player.hp -= 1; // Da√±o por proximidad
                            camera.position.x = prevX;
                            camera.position.z = prevZ;
                            updateGUI();
                        }
                    }
                }
                 // IA simple del monstruo: Perseguir al jugador
                if (obj.type === 'monster' && obj.hp > 0 && dist < 15) { // Si el jugador est√° cerca
                    const monsterSpeed = 0.03;
                    const dx = camera.position.x - obj.mesh.position.x;
                    const dz = camera.position.z - obj.mesh.position.z;
                    const angle = Math.atan2(dx, dz);
                    obj.mesh.rotation.y = angle; // Monstruo mira al jugador
                    
                    obj.mesh.position.x += Math.sin(angle) * monsterSpeed;
                    obj.mesh.position.z += Math.cos(angle) * monsterSpeed;
                }
            });

            // --- ACTUALIZAR LINTERNA ---
            flashlight.position.copy(camera.position);
            const targetOffset = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            flashlight.target.position.copy(camera.position).add(targetOffset.multiplyScalar(10));
            flashlight.target.updateMatrixWorld();
        }

        renderer.render(scene, camera);
    }

    // --- GUI Y ESTADO DEL JUGADOR ---
    function updateGUI() {
        document.getElementById('hp').innerText = Math.max(0, player.hp);
        document.getElementById('wood').innerText = player.wood;
        document.getElementById('axe').innerText = player.hasAxe ? 'S√ç' : 'NO';
    }

    animate(); // Iniciar el bucle de renderizado

    // Ajuste de tama√±o de ventana
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    updateGUI(); // Carga inicial de la GUI
</script>
</body>
</html>
